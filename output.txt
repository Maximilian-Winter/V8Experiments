<file_overview>
Total files: 3
Date generated: 2024-09-13 21:18:01
Folder Structure:
├── java_script/
│   └── test.js
└── src/
    ├── main.cpp
    └── v8_handler.h

Files included:
- java_script\test.js
- src\main.cpp
- src\v8_handler.h
</file_overview>

<file path="java_script\test.js" lines="5" modified="2024-09-13 03:21:14">
// scripts/test.js
modifyObject = function(obj) { obj.x *= 2; obj.y += 5; }
my_obj = { x: 10, y: 20 }
modifyObject(my_obj)
my_obj.x
</file>

<file path="src\main.cpp" lines="135" modified="2024-09-13 21:16:05">
// src/main.cpp
#include "v8_handler.h"
#include <iostream>
#include <fstream>
#include <sstream>

std::string ReadFile(const std::string& filename) {
    std::ifstream file(filename);
    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}

int main() {
    try {
        V8Handler v8_handler;
        v8::Isolate* isolate = v8_handler.GetIsolate();
        v8::HandleScope handle_scope(isolate);
        v8::Local<v8::Context> context = v8_handler.GetContext();
        v8::Context::Scope context_scope(context);

        // Register a C++ callback
        v8_handler.RegisterCallback("cppFunction", [](const v8::FunctionCallbackInfo<v8::Value>& args) {
            v8::Isolate* isolate = args.GetIsolate();
            v8::HandleScope handle_scope(isolate);
            std::cout << "C++ function called from JavaScript!" << std::endl;
            args.GetReturnValue().Set(v8::String::NewFromUtf8(isolate, "Hello from C++!").ToLocalChecked());
        });
        v8_handler.RegisterGCTrigger();
        // Create a JavaScript object
        auto js_object = v8_handler.CreateJSObject("({ x: 10, y: 20 })");
        if (!js_object) {
            std::cerr << "Failed to create JavaScript object" << std::endl;
            return 1;
        }

        // Use the wrapper to interact with the object
        std::cout << "Initial object: x = " << js_object->Get<int>("x")
                  << ", y = " << js_object->Get<int>("y") << std::endl;

        // Modify the object using the wrapper
        js_object->Set("x", 20);
        js_object->Set("y", 30);

        std::cout << "Modified object: x = " << js_object->Get<int>("x")
                  << ", y = " << js_object->Get<int>("y") << std::endl;
        if (!v8_handler.ExecuteJS("function modifyObject(obj) { console.log('Object received:', obj); obj.x *= 2; obj.y += 5; console.log('Object after modification:', obj); return obj; }")) {
            std::cerr << "Failed to define modifyObject function" << std::endl;
            return 1;
        }


        // Call the function with our object
        std::cout << "Calling modifyObject function..." << std::endl;
        v8::MaybeLocal<v8::Value> maybe_result = v8_handler.CallJSFunction("modifyObject", js_object->Get<>());

        // Execute JavaScript that uses the C++ callback
        v8_handler.ExecuteJS(R"(
            console.log('Calling C++ function from JavaScript');
            let result = cppFunction();
            console.log('Result:', result);
        )");

        // Create a C++ object and track it with a JavaScript object
        struct MyObject {
            int value;
            MyObject(int v) : value(v) { std::cout << "MyObject created with value " << value << std::endl; }
            ~MyObject() { std::cout << "MyObject destroyed with value " << value << std::endl; }
        };

        v8_handler.RegisterCallback("createTrackedObject", [&v8_handler](const v8::FunctionCallbackInfo<v8::Value>& args) {
            v8::Isolate* isolate = args.GetIsolate();
            v8::HandleScope handle_scope(isolate);
            v8::Local<v8::Context> context = isolate->GetCurrentContext();

            if (args.Length() < 1 || !args[0]->IsNumber()) {
                args.GetReturnValue().SetUndefined();
                return;
            }

            int value = args[0]->Int32Value(context).ToChecked();
            auto cpp_object = std::make_unique<MyObject>(value);

            v8::Local<v8::Object> js_object = v8::Object::New(isolate);
            js_object->Set(context, v8::String::NewFromUtf8(isolate, "value").ToLocalChecked(),
                           v8::Number::New(isolate, value)).Check();

            v8_handler.TrackObject(js_object, std::move(cpp_object));

            args.GetReturnValue().Set(js_object);
        });

        // Execute JavaScript that creates and uses tracked objects
        v8_handler.ExecuteJS(R"(
            console.log('Creating tracked objects');
            let obj1 = createTrackedObject(42);
            let obj2 = createTrackedObject(73);
            console.log('Tracked object 1 value:', obj1.value);
            console.log('Tracked object 2 value:', obj2.value);

            // Force garbage collection to test object tracking
            console.log('Triggering garbage collection');
            triggerGC();

            // obj1 and obj2 are still in scope, so they shouldn't be collected
            console.log('Objects should still exist');
            console.log('Tracked object 1 value:', obj1.value);
            console.log('Tracked object 2 value:', obj2.value);

            // Let obj1 go out of scope
            (function() {
                let temp = obj1;
                console.log('Temporary reference to obj1:', temp.value);
            })();

            // Force garbage collection again
            console.log('Triggering garbage collection again');
            triggerGC();

            // obj2 should still exist, but obj1 should be collected
            console.log('Only obj2 should exist now');
            console.log('Tracked object 2 value:', obj2.value);
            console.log('Tracked object 2 value:', obj1.value);
        )");

        std::cout << "JavaScript execution completed" << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "Caught exception: " << e.what() << std::endl;
    } catch (...) {
        std::cerr << "Caught unknown exception" << std::endl;
    }

    return 0;
}
</file>

<file path="src\v8_handler.h" lines="349" modified="2024-09-13 21:16:05">
#pragma once
#include <string>
#include <memory>
#include <v8.h>
#include <libplatform/libplatform.h>
#include <iostream>

class JSObjectWrapper {
public:
    JSObjectWrapper(v8::Isolate* isolate, v8::Local<v8::Object> object)
        : isolate_(isolate), persistent_(isolate, object) {}

    ~JSObjectWrapper() {
        persistent_.Reset();
    }

    template<typename T>
    T Get(const std::string& key) {
        v8::HandleScope handle_scope(isolate_);
        v8::Local<v8::Context> context = isolate_->GetCurrentContext();
        v8::Local<v8::Object> obj = persistent_.Get(isolate_);
        v8::Local<v8::String> v8_key = v8::String::NewFromUtf8(isolate_, key.c_str()).ToLocalChecked();
        v8::Local<v8::Value> value = obj->Get(context, v8_key).ToLocalChecked();
        return ConvertToNative<T>(value, context);
    }

    template<typename T>
    void Set(const std::string& key, const T& value) {
        v8::HandleScope handle_scope(isolate_);
        v8::Local<v8::Context> context = isolate_->GetCurrentContext();
        v8::Local<v8::Object> obj = persistent_.Get(isolate_);
        v8::Local<v8::String> v8_key = v8::String::NewFromUtf8(isolate_, key.c_str()).ToLocalChecked();
        v8::Local<v8::Value> v8_value = ConvertToV8(value);
        obj->Set(context, v8_key, v8_value).Check();
    }



private:
    v8::Isolate* isolate_;
    v8::Global<v8::Object> persistent_;

    template<typename T>
    T ConvertToNative(v8::Local<v8::Value> value, v8::Local<v8::Context> context) {
        if constexpr (std::is_same_v<T, int>) {
            return value->Int32Value(context).ToChecked();
        } else if constexpr (std::is_same_v<T, double>) {
            return value->NumberValue(context).ToChecked();
        } else if constexpr (std::is_same_v<T, std::string>) {
            v8::String::Utf8Value utf8(isolate_, value);
            return std::string(*utf8);
        } else {
            throw std::runtime_error("Unsupported type conversion");
        }
    }

    template<typename T>
    v8::Local<v8::Value> ConvertToV8(const T& value) {
        if constexpr (std::is_same_v<T, int>) {
            return v8::Integer::New(isolate_, value);
        } else if constexpr (std::is_same_v<T, double>) {
            return v8::Number::New(isolate_, value);
        } else if constexpr (std::is_same_v<T, std::string>) {
            return v8::String::NewFromUtf8(isolate_, value.c_str()).ToLocalChecked();
        } else {
            throw std::runtime_error("Unsupported type conversion");
        }
    }
};

class CallbackManager {
public:
    explicit CallbackManager(v8::Isolate* isolate) : isolate_(isolate) {}

    void RegisterCallback(const std::string& name, std::function<void(const v8::FunctionCallbackInfo<v8::Value>&)> callback) {
        callbacks_[name] = std::move(callback);
    }

    void ExposeCallbacks(v8::Local<v8::Context> context) {
        v8::HandleScope handle_scope(isolate_);
        v8::Local<v8::Object> global = context->Global();

        for (const auto& [name, callback] : callbacks_) {
            v8::Local<v8::String> func_name = v8::String::NewFromUtf8(isolate_, name.c_str()).ToLocalChecked();
            v8::Local<v8::Function> func = v8::Function::New(context,
                [](const v8::FunctionCallbackInfo<v8::Value>& args) {
                    v8::Isolate* isolate = args.GetIsolate();
                    v8::HandleScope handle_scope(isolate);
                    v8::Local<v8::External> data = v8::Local<v8::External>::Cast(args.Data());
                    auto* callback_ptr = static_cast<std::function<void(const v8::FunctionCallbackInfo<v8::Value>&)>*>(data->Value());
                    (*callback_ptr)(args);
                },
                v8::External::New(isolate_, const_cast<std::function<void(const v8::FunctionCallbackInfo<v8::Value>&)>*>(&callback))
            ).ToLocalChecked();

            global->Set(context, func_name, func).Check();
        }
    }

private:
    v8::Isolate* isolate_;
    std::unordered_map<std::string, std::function<void(const v8::FunctionCallbackInfo<v8::Value>&)>> callbacks_;
};

class ObjectTracker {
public:
    ObjectTracker(v8::Isolate* isolate) : isolate_(isolate) {}

    template<typename T>
    void TrackObject(v8::Local<v8::Object> js_object, std::unique_ptr<T> cpp_object) {
        v8::HandleScope handle_scope(isolate_);
        v8::Global<v8::Object> weak_global(isolate_, js_object);
        weak_global.SetWeak(
            cpp_object.get(),
            &ObjectTracker::WeakCallback<T>,
            v8::WeakCallbackType::kParameter
        );

        auto wrapped_object = std::make_unique<WrappedObject<T>>(std::move(cpp_object));
        tracked_objects_[wrapped_object.get()] = std::move(wrapped_object);
        weak_globals_[cpp_object.get()] = std::move(weak_global);
    }

private:
    v8::Isolate* isolate_;

    class WrappedObjectBase {
    public:
        virtual ~WrappedObjectBase() = default;
    };

    template<typename T>
    class WrappedObject : public WrappedObjectBase {
    public:
        explicit WrappedObject(std::unique_ptr<T> obj) : obj_(std::move(obj)) {}
        T* get() const { return obj_.get(); }
    private:
        std::unique_ptr<T> obj_;
    };

    std::unordered_map<void*, std::unique_ptr<WrappedObjectBase>> tracked_objects_;
    std::unordered_map<void*, v8::Global<v8::Object>> weak_globals_;

    template<typename T>
    static void WeakCallback(const v8::WeakCallbackInfo<T>& data) {
        T* cpp_object = static_cast<T*>(data.GetParameter());
        ObjectTracker* tracker = static_cast<ObjectTracker*>(data.GetInternalField(0));
        tracker->tracked_objects_.erase(cpp_object);
        tracker->weak_globals_.erase(cpp_object);
    }
};

class V8Handler {
public:
    V8Handler() {
        v8::V8::InitializeICUDefaultLocation(nullptr);
        v8::V8::InitializeExternalStartupData(nullptr);
        platform = v8::platform::NewDefaultPlatform();
        v8::V8::InitializePlatform(platform.get());
        v8::V8::Initialize();

        allocator = std::unique_ptr<v8::ArrayBuffer::Allocator>(v8::ArrayBuffer::Allocator::NewDefaultAllocator());

        v8::Isolate::CreateParams create_params;
        create_params.array_buffer_allocator = allocator.get();

        isolate = v8::Isolate::New(create_params);
        v8::Isolate::Scope isolate_scope(isolate);
        v8::HandleScope handle_scope(isolate);

        context.Reset(isolate, v8::Context::New(isolate));

        callback_manager = std::make_unique<CallbackManager>(isolate);
        object_tracker = std::make_unique<ObjectTracker>(isolate);

        InitializeConsole();
    }

    ~V8Handler() {
        context.Reset();
        isolate->Dispose();
        v8::V8::Dispose();
        v8::V8::DisposePlatform();
    }

    bool ExecuteJS(const std::string& js_code) {
        v8::Isolate::Scope isolate_scope(isolate);
        v8::HandleScope handle_scope(isolate);
        v8::Local<v8::Context> local_context = context.Get(isolate);
        v8::Context::Scope context_scope(local_context);

        callback_manager->ExposeCallbacks(local_context);

        v8::TryCatch try_catch(isolate);
        v8::Local<v8::String> source = v8::String::NewFromUtf8(isolate, js_code.c_str()).ToLocalChecked();
        v8::Local<v8::Script> script = v8::Script::Compile(local_context, source).ToLocalChecked();
        v8::MaybeLocal<v8::Value> result = script->Run(local_context);

        if (try_catch.HasCaught()) {
            v8::String::Utf8Value error(isolate, try_catch.Exception());
            std::cerr << "JavaScript error: " << *error << std::endl;
            return false;
        }

        return true;
    }

    std::unique_ptr<JSObjectWrapper> CreateJSObject(const std::string& js_code) {
        v8::Isolate::Scope isolate_scope(isolate);
        v8::HandleScope handle_scope(isolate);
        v8::Local<v8::Context> local_context = context.Get(isolate);
        v8::Context::Scope context_scope(local_context);

        v8::TryCatch try_catch(isolate);
        v8::Local<v8::String> source = v8::String::NewFromUtf8(isolate, js_code.c_str()).ToLocalChecked();
        v8::Local<v8::Script> script = v8::Script::Compile(local_context, source).ToLocalChecked();
        v8::MaybeLocal<v8::Value> maybe_result = script->Run(local_context);

        if (try_catch.HasCaught()) {
            v8::String::Utf8Value error(isolate, try_catch.Exception());
            std::cerr << "Error creating JS object: " << *error << std::endl;
            return nullptr;
        }

        v8::Local<v8::Value> result;
        if (!maybe_result.ToLocal(&result) || !result->IsObject()) {
            std::cerr << "Failed to create JavaScript object" << std::endl;
            return nullptr;
        }

        return std::make_unique<JSObjectWrapper>(isolate, result.As<v8::Object>());
    }

    [[nodiscard]] v8::MaybeLocal<v8::Value> CallJSFunction(const std::string& function_name, const v8::Local<v8::Value>& arg) const
    {
        v8::Isolate::Scope isolate_scope(isolate);
        v8::HandleScope handle_scope(isolate);
        v8::Local<v8::Context> local_context = context.Get(isolate);
        v8::Context::Scope context_scope(local_context);

        v8::TryCatch try_catch(isolate);
        v8::Local<v8::String> func_name = v8::String::NewFromUtf8(isolate, function_name.c_str()).ToLocalChecked();
        v8::Local<v8::Value> func_val;
        if (!local_context->Global()->Get(local_context, func_name).ToLocal(&func_val) || !func_val->IsFunction()) {
            std::cerr << "Function " << function_name << " not found or is not a function" << std::endl;
            return {};
        }

        std::cout << "Function " << function_name << " found" << std::endl;

        v8::Local<v8::Function> func = v8::Local<v8::Function>::Cast(func_val);
        v8::Local<v8::Value> args[] = { arg };

        std::cout << "Argument type: " << *v8::String::Utf8Value(isolate, arg->TypeOf(isolate)) << std::endl;
        if (arg->IsObject()) {
            v8::Local<v8::Object> obj = arg.As<v8::Object>();
            v8::Local<v8::Array> props = obj->GetOwnPropertyNames(local_context).ToLocalChecked();
            std::cout << "Object properties:" << std::endl;
            for (uint32_t i = 0; i < props->Length(); ++i) {
                v8::Local<v8::Value> key = props->Get(local_context, i).ToLocalChecked();
                v8::Local<v8::Value> value = obj->Get(local_context, key).ToLocalChecked();
                std::cout << "  " << *v8::String::Utf8Value(isolate, key) << ": " << *v8::String::Utf8Value(isolate, value) << std::endl;
            }
        }

        std::cout << "Calling function " << function_name << "..." << std::endl;
        v8::MaybeLocal<v8::Value> result = func->Call(local_context, v8::Undefined(isolate), 1, args);

        if (try_catch.HasCaught()) {
            v8::String::Utf8Value error(isolate, try_catch.Exception());
            std::cerr << "Error calling function " << function_name << ": " << *error << std::endl;
            return {};
        }

        std::cout << "Function " << function_name << " called successfully" << std::endl;
        return result;
    }
    void RegisterCallback(const std::string& name, std::function<void(const v8::FunctionCallbackInfo<v8::Value>&)> callback) {
        callback_manager->RegisterCallback(name, std::move(callback));
    }

    template<typename T>
    void TrackObject(v8::Local<v8::Object> js_object, std::unique_ptr<T> cpp_object) {
        object_tracker->TrackObject(js_object, std::move(cpp_object));
    }
    void RegisterGCTrigger() {
        RegisterCallback("triggerGC", [this](const v8::FunctionCallbackInfo<v8::Value>& args) {
            v8::Isolate* isolate = args.GetIsolate();
            isolate->LowMemoryNotification();
            //isolate->RequestGarbageCollectionForTesting(v8::Isolate::kFullGarbageCollection);
        });
    }
    v8::Isolate* GetIsolate() const { return isolate; }
    v8::Local<v8::Context> GetContext() { return context.Get(isolate); }
    void SetConsoleLogCallback(std::function<void(const std::string&)> callback) {
        console_log_callback_ = std::move(callback);
    }

private:

    void InitializeConsole() {
        v8::Isolate::Scope isolate_scope(isolate);
        v8::HandleScope handle_scope(isolate);
        v8::Local<v8::Context> local_context = context.Get(isolate);
        v8::Context::Scope context_scope(local_context);

        v8::Local<v8::Object> global = local_context->Global();

        v8::Local<v8::Object> console = v8::Object::New(isolate);
        v8::Local<v8::Function> log_function = v8::Function::New(
            local_context,
            [](const v8::FunctionCallbackInfo<v8::Value>& args) {
                v8::Isolate* isolate = args.GetIsolate();
                v8::HandleScope handle_scope(isolate);
                v8::Local<v8::Context> context = isolate->GetCurrentContext();
                v8::Local<v8::Value> data = args.Data();
                V8Handler* handler = static_cast<V8Handler*>(v8::External::Cast(*data)->Value());

                std::string result;
                for (int i = 0; i < args.Length(); i++) {
                    v8::Local<v8::Value> arg = args[i];
                    v8::String::Utf8Value value(isolate, arg);
                    if (*value) {
                        if (i > 0) result += " ";
                        result += *value;
                    }
                }

                if (handler->console_log_callback_) {
                    handler->console_log_callback_(result);
                } else {
                    std::cout << "console.log: " << result << std::endl;
                }
            },
            v8::External::New(isolate, this)
        ).ToLocalChecked();

        console->Set(local_context, v8::String::NewFromUtf8(isolate, "log").ToLocalChecked(), log_function).Check();
        global->Set(local_context, v8::String::NewFromUtf8(isolate, "console").ToLocalChecked(), console).Check();
    }

    std::function<void(const std::string&)> console_log_callback_;
    std::unique_ptr<v8::Platform> platform;
    v8::Isolate* isolate;
    v8::Global<v8::Context> context;
    std::unique_ptr<v8::ArrayBuffer::Allocator> allocator;
    std::unique_ptr<CallbackManager> callback_manager;
    std::unique_ptr<ObjectTracker> object_tracker;
};
</file>

